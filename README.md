## 系统介绍

本系统是使用 SpringBoot 开发的高并发限时抢购秒杀系统，除了实现基本的登录、查看商品列表、秒杀、下单等功能，项目中还针对高并发情况实现了系统缓存、降级和限流。

## 开发工具

IntelliJ IDEA + Navicat + Git 

## 压测工具

JMeter

## 开发技术

前端技术 ：Bootstrap + jQuery + Thymeleaf

后端技术 ：SpringBoot + MyBatis-Plus + MySQL

中间件技术 : Druid + Redis + RabbitMQ

## 实现技术点

### 1. 两次MD5加密

1. 第一次加密：客户端进行加密，将用户输入的密码和固定 Salt 通过 MD5 加密生成第一次加密后的密码，传输给服务端
2. 第二次加密：服务端接受到该密码后，和随机生成的 Salt  通过 MD5 进行第二次加密，最后将第二次加密后的密码和第一次的固定Salt存入数据库

好处：    

1. 第一次作用：防止用户明文密码在网络进行传输
2. 第二次作用：防止数据库被盗，避免通过MD5反推出密码，提高密码安全性，双重保险

### 2. JSR303 自定义参数校验

使用JSR303自定义校验器，实现对用户账号、密码的验证，使得验证逻辑从业务代码中脱离出来。

### 3. session 共享

验证用户账号密码都正确情况下，通过 UUID 生成唯一 id 作为 token ，再将 token 作为 key 、用户信息作为 value 模拟session 存储到 redis 中，同时将 token 存储到 cookie ，保存登录状态。

好处： 在分布式集群情况下，服务器间需要同步，定时同步各个服务器的 session 信息，会因为延迟到导致 session 不一致，使用 redis 把 session 数据集中存储起来，解决 session 不一致问题。

### 4. 全局异常统一处理

通过拦截所有异常，对各种异常进行相应的处理，当遇到异常就逐层上抛，一直抛到最终由一个统一的、专门负责异常处理的地方处理，这有利于对异常的维护。

### 5. 页面缓存 + 对象缓存

1. 页面缓存：通过在手动渲染得到的 html 页面缓存到 redis，访问页面时，先查询redis中是否存在，若存在则直接返回
2. 对象缓存：包括对用户信息、商品信息、订单信息和 token 等数据进行缓存，利用缓存来减少对数据库的访问，大大加快查询速度。

### 6. 页面静态化

对商品详情和订单详情进行页面静态化处理，页面是存在html，动态数据是通过接口从服务端获取，实现前后端分离，静态页面无需连接数据库打开速度较动态页面会有明显提高

### 7. 本地标记 + redis预处理 + RabbitMQ异步下单 + 客户端轮询

描述：通过三级缓冲保护，1、本地标记  2、redis预处理  3、RabbitMQ异步下单，最后才会访问数据库，这样做是为了最大力度减少对数据库的访问。

实现：

1. 在秒杀阶段使用本地标记对用户秒杀过的商品做标记，若被标记过直接返回重复秒杀，未被标记才查询redis，通过本地标记来减少对redis的访问
2. 抢购开始前，将商品和库存数据同步到redis中，所有的抢购操作都在redis中进行处理，通过Redis预减少库存减少数据库访问
3. 为了保护系统不受高流量的冲击而导致系统崩溃的问题，使用RabbitMQ用异步队列处理下单，实际做了一层缓冲保护，做了一个窗口模型，窗口模型会实时的刷新用户秒杀的状态。
4. client端用 js 轮询一个接口，用来获取处理状态

### 8. 解决超卖

描述：比如某商品的库存为 1 ，此时用户1和用户 2 并发购买该商品，用户 1 提交订单后该商品的库存被修改为 0，而此时用户2 并不知道的情况下提交订单，该商品的库存再次被修改为 -1 ，这就是超卖现象。

实现：

1. 对库存更新时，先对库存判断，只有当库存大于0才能更新库存
2. 对用户id和商品id建立一个唯一索引，通过这种约束避免同一用户发同时两个请求秒杀到两件相同商品
3. 实现乐观锁，给商品信息表增加一个version字段，为每一条数据加上版本。每次更新的时候version+1，并且更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试。

### 9. 接口地址隐藏

描述：秒杀页面中如果商品秒杀链接提前暴露出去可能直接访问 URL 就提前秒杀了商品，所以应将 URL 动态化。

实现

1. 进行秒杀之前，先请求一个服务端地址，用来获取秒杀地址，传入商品id，用户信息，使用 MD5 生成随机数作为 seckillPath 存入Redis 缓存中，设定过期时间，并将这个随机数返回前端。
2. 获取到随机数 seckillPath 拼接上 URL 进行访问
3. 后端收到后，与缓存中的 seckillPath 进行比较
   1. 如果通过，则进行秒杀逻辑
   2. 如果不通过，抛出 请求非法，请重新尝试。

### 10. 使用数学公式验证码

描述：点击秒杀前，先输入验证码，验证正确才能进行秒杀，分散用户请求

实现

1. 用户访问商品详情时，将商品id和用户信息传入验证码接口
2. 服务端生成验证码，使用用户 id 和商品 id 作为 key，验证码信息作为 value 存入 Redis 中，同时将生成的验证码图片返回给前端
3. 用户进行秒杀时，服务端先将传入验证码信息与缓存中比较，如果相同，则执行秒杀逻辑，如果错误，则抛出验证码错误，请重新输入。

### 11 自定义注解 + 拦截器 + Redis 实现简单接口限流

描述：限制同一个用户在一定时间内，只能访问固定的次数。

实现

1. 使用自定义注解，配置指定时间、最大访问量、和是否需要登录
2. 在指定方法上添加注解，添加以上信息
3. 用户每次发起请求之后，在缓存中生成一个计数器，第一次将这个计数器置为1后存入缓存，并设定过期时间
4. 之后每次发起请求，取出这个值，计数器加一，如果超出限定次数，就抛出业务异常

